<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus API Gateway | Enterprise Edition</title>
    <style>
        :root {
            --bg-dark: #0f172a;
            --bg-panel: #1e293b;
            --primary: #3b82f6;
            --accent: #8b5cf6;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --border: #334155;
            --font-mono: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
        }

        * { box-sizing: border-box; outline: none; scrollbar-width: thin; scrollbar-color: var(--primary) var(--bg-dark); }

        body {
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-columns: 300px 1fr;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10;
        }

        .brand {
            font-size: 1.2rem;
            font-weight: 800;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-main);
        }
        .brand span { color: var(--primary); }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); font-weight: 600; margin-bottom: 5px; display: block; }

        input, select {
            width: 100%;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 10px;
            border-radius: 6px;
            font-family: inherit;
            transition: border 0.2s;
        }
        input:focus, select:focus { border-color: var(--primary); }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn:hover { filter: brightness(1.1); transform: translateY(-1px); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { background: var(--border); color: var(--text-muted); cursor: not-allowed; transform: none; }
        
        .btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-muted); }
        .btn-outline:hover { border-color: var(--text-main); color: var(--text-main); }

        /* --- TERMINAL --- */
        .terminal-window {
            background: #000;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 0.7rem;
            height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse; /* Newest at bottom visually if we prepend, but here we append */
        }
        .log-entry { margin-bottom: 4px; border-left: 2px solid transparent; padding-left: 5px; }
        .log-info { color: var(--primary); border-color: var(--primary); }
        .log-success { color: var(--success); border-color: var(--success); }
        .log-error { color: var(--danger); border-color: var(--danger); }
        .log-warn { color: var(--warning); border-color: var(--warning); }

        /* --- MAIN CONTENT --- */
        main {
            display: grid;
            grid-template-rows: auto 1fr;
            overflow: hidden;
            position: relative;
        }

        /* HUD / Dashboard */
        .hud {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metrics { display: flex; gap: 20px; }
        .metric-card { display: flex; flex-direction: column; }
        .metric-val { font-size: 1.1rem; font-weight: 700; font-family: var(--font-mono); }
        .metric-label { font-size: 0.7rem; color: var(--text-muted); }

        /* Canvas Chart */
        .chart-container {
            width: 150px;
            height: 40px;
        }

        /* Content Grid */
        .workspace {
            display: grid;
            grid-template-columns: 1fr 1fr;
            overflow: hidden;
        }

        .panel {
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            min-width: 0;
        }
        .panel:last-child { border-right: none; }

        .panel-header {
            padding: 10px 15px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0;
            position: relative;
        }

        /* Raw View */
        pre {
            margin: 0;
            padding: 15px;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: #a5b4fc;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        /* Parsed View */
        .result-card {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }
        .result-card:hover { background: rgba(255,255,255,0.02); }

        .tags { display: flex; gap: 8px; margin-bottom: 8px; }
        .tag { 
            font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; font-weight: 700; text-transform: uppercase; 
        }
        .tag-html { background: rgba(249, 115, 22, 0.2); color: #fb923c; }
        .tag-json { background: rgba(139, 92, 246, 0.2); color: #a78bfa; }
        .tag-sentiment-pos { background: rgba(16, 185, 129, 0.2); color: #34d399; }
        .tag-sentiment-neu { background: rgba(148, 163, 184, 0.2); color: #cbd5e1; }
        
        .res-link { font-size: 0.75rem; color: var(--success); display: block; margin-bottom: 4px; text-decoration: none; }
        .res-title { font-size: 1.1rem; color: var(--primary); font-weight: 600; text-decoration: none; display: block; margin-bottom: 8px; }
        .res-title:hover { text-decoration: underline; }
        
        .res-snippet { font-size: 0.9rem; color: var(--text-muted); line-height: 1.6; }
        .highlight { background: rgba(250, 204, 21, 0.2); color: #facc15; padding: 0 2px; border-radius: 2px; }

        /* Loading Overlay */
        .loader-overlay {
            position: absolute;
            top:0; left:0; right:0; bottom:0;
            background: rgba(15, 23, 42, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            backdrop-filter: blur(2px);
            display: none;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid var(--primary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 1000px) {
            body { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            aside { display: none; } /* Hide sidebar on mobile for simplicity, or make it a drawer */
            .workspace { grid-template-columns: 1fr; }
            .panel:first-child { display: none; } /* Hide raw on mobile */
        }
    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <aside>
        <div class="brand">
            <span>◆</span> NEXUS GATEWAY
        </div>

        <div class="control-panel">
            <div>
                <label>Target Endpoint</label>
                <select id="endpointMode">
                    <option value="html">HTML Scraper (Deep)</option>
                    <option value="json">API (Fast/Lite)</option>
                </select>
            </div>

            <div>
                <label>Search Query</label>
                <input type="text" id="queryInput" placeholder="Enter keywords..." value="javascript async await">
            </div>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <div>
                    <label>Max RPM</label>
                    <input type="number" id="rpmInput" value="10" min="1" max="100">
                </div>
                <div>
                    <label>Timeout (ms)</label>
                    <input type="number" id="timeoutInput" value="5000" step="500">
                </div>
            </div>

            <button id="execBtn" class="btn">
                <span>⚡</span> INITIALIZE REQUEST
            </button>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <button id="exportJsonBtn" class="btn btn-outline" disabled>JSON</button>
                <button id="exportCsvBtn" class="btn btn-outline" disabled>CSV</button>
            </div>
        </div>

        <div style="flex-grow:1"></div>

        <div>
            <label>System Terminal</label>
            <div class="terminal-window" id="terminal">
                <div class="log-entry log-info">> System initialized.</div>
                <div class="log-entry log-info">> Waiting for input...</div>
            </div>
        </div>
    </aside>

    <!-- MAIN INTERFACE -->
    <main>
        <!-- HUD -->
        <div class="hud">
            <div class="metrics">
                <div class="metric-card">
                    <span class="metric-val" id="statusIndicator" style="color:var(--success)">IDLE</span>
                    <span class="metric-label">GATEWAY STATUS</span>
                </div>
                <div class="metric-card">
                    <span class="metric-val" id="reqCount">0</span>
                    <span class="metric-label">REQUESTS (1M)</span>
                </div>
                <div class="metric-card">
                    <span class="metric-val" id="latencyVal">0ms</span>
                    <span class="metric-label">LAST LATENCY</span>
                </div>
            </div>

            <!-- Canvas Latency Chart -->
            <div class="chart-container">
                <canvas id="latencyChart" width="150" height="40"></canvas>
            </div>
        </div>

        <!-- WORKSPACE -->
        <div class="workspace">
            
            <!-- RAW DATA PANEL -->
            <div class="panel">
                <div class="panel-header">
                    <span>Inbound Data Stream</span>
                    <span style="font-size:0.7rem; opacity:0.7">READ-ONLY</span>
                </div>
                <div class="panel-body">
                    <pre id="rawOutput">// Data stream empty.</pre>
                </div>
            </div>

            <!-- PARSED RESULTS PANEL -->
            <div class="panel">
                <div class="panel-header">
                    <span>Processed Intelligence</span>
                    <span id="resultCountBadge">0 ITEMS</span>
                </div>
                <div class="panel-body" id="parsedOutput">
                    <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; color:var(--text-muted); text-align:center; padding:40px;">
                        <div style="font-size:3rem; margin-bottom:10px; opacity:0.2">◈</div>
                        <p>No intelligence data gathered.</p>
                    </div>
                </div>
                <!-- Loader -->
                <div class="loader-overlay" id="loader">
                    <div class="spinner"></div>
                </div>
            </div>

        </div>
    </main>

    <script>
        /**
         * =============================================================================
         * NEXUS CORE ENGINE
         * =============================================================================
         */

        class NexusGateway {
            constructor() {
                this.state = {
                    history: [],
                    lastResults: null,
                    rpm: 0,
                    rpmStartTime: Date.now(),
                    isLocked: false,
                    latencies: []
                };

                // Configuration
                this.proxies = [
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.io/?', 
                    // Fallback strategy: if one fails, engine switches
                ];
                
                this.ui = new UIManager(this);
                this.parser = new HeuristicParser();
                
                this.bindEvents();
                this.startClock();
            }

            bindEvents() {
                document.getElementById('execBtn').addEventListener('click', () => this.executeSearch());
                document.getElementById('exportJsonBtn').addEventListener('click', () => this.export('json'));
                document.getElementById('exportCsvBtn').addEventListener('click', () => this.export('csv'));
                
                // Enter key support
                document.getElementById('queryInput').addEventListener('keypress', (e) => {
                    if(e.key === 'Enter') this.executeSearch();
                });
            }

            startClock() {
                // Reset RPM counter every minute
                setInterval(() => {
                    this.state.rpm = 0;
                    this.state.rpmStartTime = Date.now();
                    this.ui.updateMetrics(this.state);
                    this.ui.log("RPM Window Reset", "info");
                }, 60000);
            }

            async executeSearch() {
                const query = document.getElementById('queryInput').value.trim();
                const mode = document.getElementById('endpointMode').value;
                const maxRpm = parseInt(document.getElementById('rpmInput').value);
                const timeout = parseInt(document.getElementById('timeoutInput').value);

                if (!query) return this.ui.log("Query empty. Aborting.", "error");

                // 1. Rate Limiting Check
                if (this.state.rpm >= maxRpm) {
                    this.ui.log(`Rate Limit Exceeded (${maxRpm}). Cooldown active.`, "warn");
                    this.ui.setStatus("LOCKED", "danger");
                    return;
                }

                // 2. Lock UI
                this.ui.setLoading(true);
                this.ui.setStatus("FETCHING", "warning");
                this.ui.log(`Initializing request: "${query}" via ${mode.toUpperCase()}`, "info");

                const startTime = performance.now();

                try {
                    // 3. Fetch Data (with Proxy Failover)
                    const rawData = await this.fetchWithFailover(query, mode, timeout);
                    
                    // 4. Parse Data
                    this.ui.log("Parsing response stream...", "info");
                    let results = [];
                    
                    if (mode === 'html') {
                        results = this.parser.parseHTML(rawData, query);
                    } else {
                        results = this.parser.parseJSON(rawData, query);
                    }

                    const endTime = performance.now();
                    const latency = Math.round(endTime - startTime);
                    
                    // 5. Update State
                    this.state.rpm++;
                    this.state.lastResults = results;
                    this.state.latencies.push(latency);
                    if (this.state.latencies.length > 20) this.state.latencies.shift();

                    // 6. Render
                    this.ui.renderRaw(rawData);
                    this.ui.renderResults(results);
                    this.ui.updateMetrics(this.state, latency);
                    this.ui.drawChart(this.state.latencies);
                    
                    this.ui.log(`Success. ${results.length} items extracted in ${latency}ms.`, "success");
                    this.ui.setStatus("IDLE", "success");

                } catch (error) {
                    this.ui.log(`Critical Failure: ${error.message}`, "error");
                    this.ui.renderRaw(error.stack);
                    this.ui.setStatus("ERROR", "danger");
                } finally {
                    this.ui.setLoading(false);
                }
            }

            /**
             * Tries multiple proxies if the first one fails or times out.
             */
            async fetchWithFailover(query, mode, timeoutMs) {
                const timestamp = Date.now();
                let targetUrl = '';
                
                if (mode === 'html') {
                    targetUrl = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}&t=${timestamp}`;
                } else {
                    targetUrl = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&t=${timestamp}`;
                }

                // Try proxies sequentially
                for (const proxyBase of this.proxies) {
                    const fullUrl = proxyBase + encodeURIComponent(targetUrl);
                    this.ui.log(`Attempting connection via ${new URL(proxyBase).hostname}...`, "info");
                    
                    try {
                        const controller = new AbortController();
                        const id = setTimeout(() => controller.abort(), timeoutMs);
                        
                        const response = await fetch(fullUrl, { signal: controller.signal });
                        clearTimeout(id);

                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const text = await response.text();
                        
                        // Validation: Did we get a proxy error page instead of content?
                        if (text.includes("Access Denied") || text.length < 100) {
                            throw new Error("Proxy returned invalid content");
                        }

                        return text; // Success

                    } catch (err) {
                        this.ui.log(`Proxy ${new URL(proxyBase).hostname} failed: ${err.message}`, "warn");
                        // Continue to next proxy
                    }
                }
                
                throw new Error("All proxy gateways failed. Network unreachable.");
            }

            export(format) {
                if (!this.state.lastResults || this.state.lastResults.length === 0) return;
                
                let content = "";
                let mime = "text/plain";
                let filename = `nexus_export_${Date.now()}`;

                if (format === 'json') {
                    content = JSON.stringify(this.state.lastResults, null, 2);
                    mime = "application/json";
                    filename += ".json";
                } else {
                    // CSV
                    const headers = ["Title", "URL", "Snippet", "Source"];
                    const rows = this.state.lastResults.map(r => 
                        `"${r.title.replace(/"/g, '""')}","${r.url}","${r.snippet.replace(/"/g, '""')}","${r.source}"`
                    );
                    content = headers.join(",") + "\n" + rows.join("\n");
                    mime = "text/csv";
                    filename += ".csv";
                }

                const blob = new Blob([content], { type: mime });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                this.ui.log(`Exported data as ${format.toUpperCase()}`, "success");
            }
        }

        /**
         * =============================================================================
         * HEURISTIC PARSER
         * Intelligent parsing that doesn't rely solely on brittle class names
         * =============================================================================
         */
        class HeuristicParser {
            
            parseHTML(html, query) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const results = [];
                const keywords = query.toLowerCase().split(' ');

                // Strategy 1: Standard DDG Classes (Fastest)
                const standardNodes = doc.querySelectorAll('.result');
                if (standardNodes.length > 0) {
                    standardNodes.forEach(node => {
                        const titleEl = node.querySelector('.result__a');
                        const snippetEl = node.querySelector('.result__snippet');
                        const urlEl = node.querySelector('.result__url');
                        
                        if (titleEl) {
                            results.push(this.formatResult(
                                titleEl.innerText,
                                titleEl.getAttribute('href'),
                                snippetEl ? snippetEl.innerText : '',
                                urlEl ? urlEl.innerText : 'duckduckgo.com',
                                'HTML',
                                keywords
                            ));
                        }
                    });
                } 
                
                // Strategy 2: Heuristic Fallback (If classes changed)
                // Look for structure: <a> (title) followed closely by <div> (snippet)
                if (results.length === 0) {
                    const allLinks = doc.querySelectorAll('a');
                    allLinks.forEach(a => {
                        // Heuristic: Result links usually have "uddg" in href or are absolute URLs not pointing to DDG
                        const href = a.getAttribute('href');
                        if (href && !href.startsWith('/') && !href.includes('duckduckgo.com')) {
                            // Check if it has a sibling that looks like a snippet
                            const parent = a.parentElement;
                            const snippetCandidate = parent.nextElementSibling;
                            
                            if (snippetCandidate && snippetCandidate.innerText.length > 20) {
                                results.push(this.formatResult(
                                    a.innerText,
                                    href,
                                    snippetCandidate.innerText,
                                    new URL(href).hostname,
                                    'Heuristic',
                                    keywords
                                ));
                            }
                        }
                    });
                }

                return results;
            }

            parseJSON(jsonString, query) {
                try {
                    const data = JSON.parse(jsonString);
                    const results = [];
                    const keywords = query.toLowerCase().split(' ');

                    if (data.AbstractText) {
                        results.push(this.formatResult(
                            data.Heading,
                            data.AbstractURL,
                            data.AbstractText,
                            data.AbstractSource,
                            'Instant Answer',
                            keywords
                        ));
                    }

                    if (data.RelatedTopics) {
                        data.RelatedTopics.forEach(t => {
                            if (t.Text && t.FirstURL) {
                                results.push(this.formatResult(
                                    t.Text.split(' - ')[0],
                                    t.FirstURL,
                                    t.Text,
                                    'Related',
                                    'API',
                                    keywords
                                ));
                            }
                        });
                    }
                    return results;
                } catch (e) {
                    throw new Error("JSON Parse Failed");
                }
            }

            formatResult(title, url, snippet, source, type, keywords) {
                // Sentiment Analysis (Lite)
                const text = (title + " " + snippet).toLowerCase();
                let sentiment = 'neu';
                if (text.match(/best|top|amazing|good|excellent|love/)) sentiment = 'pos';
                if (text.match(/bad|worst|avoid|hate|error|fail/)) sentiment = 'neg';

                return {
                    title: title.trim(),
                    url: url,
                    snippet: snippet.trim(),
                    source: source.trim(),
                    type: type,
                    sentiment: sentiment,
                    keywords: keywords
                };
            }
        }

        /**
         * =============================================================================
         * UI MANAGER
         * Handles DOM updates, Charts, and Terminal
         * =============================================================================
         */
        class UIManager {
            constructor(engine) {
                this.engine = engine;
                this.terminal = document.getElementById('terminal');
                this.canvas = document.getElementById('latencyChart');
                this.ctx = this.canvas.getContext('2d');
            }

            log(msg, type = 'info') {
                const div = document.createElement('div');
                div.className = `log-entry log-${type}`;
                const time = new Date().toLocaleTimeString().split(' ')[0];
                div.innerText = `[${time}] ${msg}`;
                this.terminal.appendChild(div);
                this.terminal.scrollTop = this.terminal.scrollHeight;
            }

            setStatus(text, type) {
                const el = document.getElementById('statusIndicator');
                el.innerText = text;
                el.style.color = `var(--${type})`;
            }

            setLoading(isLoading) {
                document.getElementById('loader').style.display = isLoading ? 'flex' : 'none';
                document.getElementById('execBtn').disabled = isLoading;
            }

            updateMetrics(state, lastLatency) {
                document.getElementById('reqCount').innerText = state.rpm;
                if (lastLatency) document.getElementById('latencyVal').innerText = lastLatency + 'ms';
            }

            renderRaw(data) {
                const el = document.getElementById('rawOutput');
                // Truncate if massive to prevent DOM freeze
                el.textContent = data.length > 50000 ? data.substring(0, 50000) + '... [TRUNCATED]' : data;
            }

            renderResults(results) {
                const container = document.getElementById('parsedOutput');
                const badge = document.getElementById('resultCountBadge');
                const btnJson = document.getElementById('exportJsonBtn');
                const btnCsv = document.getElementById('exportCsvBtn');

                container.innerHTML = '';
                badge.innerText = `${results.length} ITEMS`;

                if (results.length > 0) {
                    btnJson.disabled = false;
                    btnCsv.disabled = false;
                    
                    results.forEach(r => {
                        // Highlight keywords
                        let safeSnippet = this.escapeHtml(r.snippet);
                        r.keywords.forEach(k => {
                            if (k.length > 2) {
                                const regex = new RegExp(`(${k})`, 'gi');
                                safeSnippet = safeSnippet.replace(regex, '<span class="highlight">$1</span>');
                            }
                        });

                        const div = document.createElement('div');
                        div.className = 'result-card';
                        div.innerHTML = `
                            <div class="tags">
                                <span class="tag tag-html">${r.type}</span>
                                <span class="tag tag-sentiment-${r.sentiment}">${r.sentiment.toUpperCase()}</span>
                            </div>
                            <a href="${r.url}" target="_blank" class="res-link">${this.escapeHtml(r.source)}</a>
                            <a href="${r.url}" target="_blank" class="res-title">${this.escapeHtml(r.title)}</a>
                            <div class="res-snippet">${safeSnippet}</div>
                        `;
                        container.appendChild(div);
                    });
                } else {
                    btnJson.disabled = true;
                    btnCsv.disabled = true;
                    container.innerHTML = `<div style="padding:20px; text-align:center; color:var(--text-muted)">No results found. Try a different query or mode.</div>`;
                }
            }

            drawChart(dataPoints) {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                ctx.clearRect(0, 0, w, h);
                if (dataPoints.length < 2) return;

                ctx.beginPath();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;

                const step = w / (dataPoints.length - 1);
                const max = Math.max(...dataPoints, 100); // Scale based on max latency

                dataPoints.forEach((val, i) => {
                    const x = i * step;
                    const y = h - ((val / max) * h);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.stroke();
                
                // Fill
                ctx.lineTo(w, h);
                ctx.lineTo(0, h);
                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                ctx.fill();
            }

            escapeHtml(str) {
                if (!str) return '';
                return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
            }
        }

        // Initialize Application
        const app = new NexusGateway();

    </script>
</body>
</html>
